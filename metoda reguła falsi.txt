#include <stdio.h>
#include <conio.h>
#include <math.h>
 
 
int n,p,q;
float a[100];
 
 
float w(int k, float x) //algorytm Hornera - obliczanie wartosci wielomianu
{
if (k==n)
{return a[n];}
else
{return w(k+1,x)*x+a[k];}
}
 
 
float s(int j)           //Algorytm Show-Trauba funkcja pomocnicza s(j)
{
return (n-j)%q;
}
 
float r(int j)           //Algorytm Show-Trauba funkcja pomocnicza r(j)
{
if (j%q==0)
return q;
else
return 0;
}
 
float T(int i, int j, float x)//Algorytm Show-Trauba - glowna funkcja
{
if (x==0)                     //by mozna bylo obliczyc pochodna w punkcie x=0
return a[j];
else
if (j==-1)
return a[n-i-1]*pow(x,s(i+1));
else
if (i==j)
return a[n]*pow(x,s(0));
else
return T(i-1, j-1, x)+T(i-1, j, x)*pow(x,r(i-j));
}
 
 
float pochodna(int stopien, float punkt)
{
if (punkt==0) return T(n,stopien,punkt); else return T(n,stopien,punkt)/pow(punkt,stopien%q);
}
 
 
 
main()
{
int k,l;
float y,z,c;
clrscr();
printf("Metoda Ragula Falsi - obliczanie zer funkcji nie liniowych\nna przykladzie wielomianow\nPodaj stopien wielomianu\n");
scanf("%d", &n);
if (n>100)
{printf("Za duzy stopien wielomianu"); getche(); return(1); }
if (n<2)
{printf("Za maly stopien wielomianu"); getche(); return(1); }
 
 
printf("\nPodaj teraz kolejne wspolczynniki wielomianu.\nZaczynij od tego z najwieksza potega.\n");
for(k=n; k>=0; k--)
{printf("a%d ", k);
scanf("%e", &a[k]);}
 
printf("Podaj poczatek przedzialu\n");
scanf("%e",&y);
printf("Podaj koniec przedzialu\n");
scanf("%e",&z);
if (z<y) {printf("Koniec przedzialu jest mniejszy od poczatku"); getche(); return(1);}
printf("Podaj liczbe iteracji\n");
scanf("%d",&l);
p=1; q=n+1;
 
if ((pochodna(1,y)*pochodna(2,y))<0)
{c=z; for (k=1; k<=l; k++) {c=c-(w(0,c)/(w(0,y)-w(0,c)))*(y-c); if (w(0,c)==0) {break;}}}
else
{c=y; for (k=1; k<=l; k++) {c=c-(w(0,c)/(w(0,z)-w(0,c)))*(z-c); if (w(0,c)==0) {break;}}}
 
if (w(0,c)==0) {printf("Dokladny pierwiastek wynosi %f",c);}
else {printf("Przyblizony pierwiastek wynosi %f",c);}
 
getche();
return(0);
}
for i:=0 to 100 do
for j:=0 to 100 do v[i,j]:=v_bok[5];
 
bWarunek := false; //war zakonczenia
 
epsmax := 0.1;
 
repeat
// obliczenia numeryczne (metoda Gaussa-Seidla)
for i:=0 to 100 do
for j:=0 to 100 do begin
if i = 0   then V[i,j]:=V_bok[4] else
if i = 100 then V[i,j]:=V_bok[3] else
//if i = 100 then V[i,j]:=V[i-1,j] else //przy warunku Neumana
if j = 0   then V[i,j]:=V_bok[1] else
if j = 100 then V[i,j]:=V_bok[2] else
if (i in [40..45]) and (j in [40..45]) then V[i,j]:=V_bok[6] //zaburzenie osrodka
 
else  // z przedzialu
V[i,j]:=(V[i-1,j]+V[i+1,j]+V[i,j-1]+V[i,j+1])/4;
eps:=eps+abs(V[i,j]-Vs)
end;
// wyswietlenie wyniku
for i:=0 to 100 do
for j:=0 to 100 do imgRozklad.Canvas.Pixels[i,j]:=ktory_color(V[i,j]);
 
Image1.Canvas.StretchDraw(Image1.Canvas.ClipRect,imgRozklad);
Image1.Invalidate;
Application.ProcessMessages;
 
until ((eps/MaxV)<epsmax) or bWarunek;
end;
 
procedure TRozklad.btnPrzerwijClick(Sender: TObject);
begin
bWarunek := true;
end;
 
end.